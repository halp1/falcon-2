#[derive(Clone, Copy)]
pub enum Mino {
	I,
	J,
	L,
	O,
	S,
	T,
	Z,
}

pub struct TetrominoMatrix {
  pub w: u32,
  pub h: u32,
  pub dx: i32,
  pub dy: i32,
  pub data: [[(u32, u32); 4]; 4],
}

pub const TETROMINO_I: TetrominoMatrix = TetrominoMatrix {
  w: 4,
  h: 4,
  dx: 1,
  dy: 1,
  data: [
    [(0, 1), (1, 1), (2, 1), (3, 1)],
    [(2, 0), (2, 1), (2, 2), (2, 3)],
    [(3, 2), (2, 2), (1, 2), (0, 2)],
    [(1, 3), (1, 2), (1, 1), (1, 0)],
  ],
};

pub const TETROMINO_J: TetrominoMatrix = TetrominoMatrix {
  w: 3,
  h: 3,
  dx: 1,
  dy: 1,
  data: [
    [(0, 0), (0, 1), (1, 1), (2, 1)],
    [(2, 0), (1, 0), (1, 1), (1, 2)],
    [(2, 2), (2, 1), (1, 1), (0, 1)],
    [(0, 2), (1, 2), (1, 1), (1, 0)],
  ],
};

pub const TETROMINO_L: TetrominoMatrix = TetrominoMatrix {
  w: 3,
  h: 3,
  dx: 1,
  dy: 1,
  data: [
    [(2, 0), (0, 1), (1, 1), (2, 1)],
    [(2, 2), (1, 0), (1, 1), (1, 2)],
    [(0, 2), (2, 1), (1, 1), (0, 1)],
    [(0, 0), (1, 2), (1, 1), (1, 0)],
  ],
};

pub const TETROMINO_O: TetrominoMatrix = TetrominoMatrix {
  w: 2,
  h: 2,
  dx: 0,
  dy: 1,
  data: [
    [(0, 0), (1, 0), (0, 1), (1, 1)],
    [(1, 0), (1, 1), (0, 0), (0, 1)],
    [(1, 1), (0, 1), (1, 0), (0, 0)],
    [(0, 1), (0, 0), (1, 1), (1, 0)],
  ],
};

pub const TETROMINO_S: TetrominoMatrix = TetrominoMatrix {
  w: 3,
  h: 3,
  dx: 1,
  dy: 1,
  data: [
    [(1, 0), (2, 0), (0, 1), (1, 1)],
    [(2, 1), (2, 2), (1, 0), (1, 1)],
    [(1, 2), (0, 2), (2, 1), (1, 1)],
    [(0, 1), (0, 0), (1, 2), (1, 1)],
  ],
};

pub const TETROMINO_T: TetrominoMatrix = TetrominoMatrix {
  w: 3,
  h: 3,
  dx: 1,
  dy: 1,
  data: [
    [(1, 0), (0, 1), (1, 1), (2, 1)],
    [(2, 1), (1, 0), (1, 1), (1, 2)],
    [(1, 2), (2, 1), (1, 1), (0, 1)],
    [(0, 1), (1, 2), (1, 1), (1, 0)],
  ],
};

pub const TETROMINO_Z: TetrominoMatrix = TetrominoMatrix {
  w: 3,
  h: 3,
  dx: 1,
  dy: 1,
  data: [
    [(0, 0), (1, 0), (1, 1), (2, 1)],
    [(2, 0), (2, 1), (1, 1), (1, 2)],
    [(2, 2), (1, 2), (1, 1), (0, 1)],
    [(0, 2), (0, 1), (1, 1), (1, 0)],
  ],
};

pub fn get_tetromino_data(mino: Mino) -> &'static TetrominoMatrix {
  match mino {
    Mino::I => &TETROMINO_I,
    Mino::J => &TETROMINO_J,
    Mino::L => &TETROMINO_L,
    Mino::O => &TETROMINO_O,
    Mino::S => &TETROMINO_S,
    Mino::T => &TETROMINO_T,
    Mino::Z => &TETROMINO_Z,
  }
}

pub enum KickTable {
	SRS,
	SRSPlus,
}

pub struct KickData {
  pub standard: [[(i8, i8); 5]; 12],
  pub i: [[(i8, i8); 5]; 12],
}

pub const SRS_KICKS: KickData = KickData {
	standard: [
		[(0, 0), (-1, 0), (-1, -1), (0, 2), (-1, 2)], // 0->1
		[(0, 0), (1, 0), (1, 1), (0, -2), (1, -2)],   // 1->0
		[(0, 0), (1, 0), (1, 1), (0, -2), (1, -2)],   // 1->2
		[(0, 0), (-1, 0), (-1, -1), (0, 2), (-1, 2)], // 2->1
		[(0, 0), (1, 0), (1, -1), (0, 2), (1, 2)],    // 2->3
		[(0, 0), (-1, 0), (-1, 1), (0, -2), (-1, -2)], // 3->2
		[(0, 0), (-1, 0), (-1, 1), (0, -2), (-1, -2)], // 3->0
		[(0, 0), (1, 0), (1, -1), (0, 2), (1, 2)],    // 0->3
		[(0, -1), (1, -1), (-1, -1), (1, 0), (-1, 0)], // 0->2
		[(1, 0), (1, -2), (1, -1), (0, -2), (0, -1)], // 1->3
		[(0, 1), (-1, 1), (1, 1), (-1, 0), (1, 0)],   // 2->0
		[(-1, 0), (-1, -2), (-1, -1), (0, -2), (0, -1)], // 3->1
	],
	i: [
		[(0, 0), (-2, 0), (1, 0), (-2, 1), (1, -2)],  // 0->1
		[(0, 0), (2, 0), (-1, 0), (2, -1), (-1, 2)],  // 1->0
		[(0, 0), (-1, 0), (2, 0), (-1, -2), (2, 1)],  // 1->2
		[(0, 0), (1, 0), (-2, 0), (1, 2), (-2, -1)],  // 2->1
		[(0, 0), (2, 0), (-1, 0), (2, -1), (-1, 2)],  // 2->3
		[(0, 0), (-2, 0), (1, 0), (-2, 1), (1, -2)],  // 3->2
		[(0, 0), (1, 0), (-2, 0), (1, 2), (-2, -1)],  // 3->0
		[(0, 0), (-1, 0), (2, 0), (-1, -2), (2, 1)],  // 0->3
		[(0, 0), (0, 0), (0, 0), (0, 0), (0, 0)],     // 0->2
		[(0, 0), (0, 0), (0, 0), (0, 0), (0, 0)],     // 1->3
		[(0, 0), (0, 0), (0, 0), (0, 0), (0, 0)],     // 2->0
		[(0, 0), (0, 0), (0, 0), (0, 0), (0, 0)],     // 3->1
	],
};

pub const SRS_PLUS_KICKS: KickData = KickData {
	standard: [
		[(0, 0), (-1, 0), (-1, -1), (0, 2), (-1, 2)], // 0->1
		[(0, 0), (1, 0), (1, 1), (0, -2), (1, -2)],   // 1->0
		[(0, 0), (1, 0), (1, 1), (0, -2), (1, -2)],   // 1->2
		[(0, 0), (-1, 0), (-1, -1), (0, 2), (-1, 2)], // 2->1
		[(0, 0), (1, 0), (1, -1), (0, 2), (1, 2)],    // 2->3
		[(0, 0), (-1, 0), (-1, 1), (0, -2), (-1, -2)], // 3->2
		[(0, 0), (-1, 0), (-1, 1), (0, -2), (-1, -2)], // 3->0
		[(0, 0), (1, 0), (1, -1), (0, 2), (1, 2)],    // 0->3
		[(0, -1), (1, -1), (-1, -1), (1, 0), (-1, 0)], // 0->2
		[(1, 0), (1, -2), (1, -1), (0, -2), (0, -1)], // 1->3
		[(0, 1), (-1, 1), (1, 1), (-1, 0), (1, 0)],   // 2->0
		[(-1, 0), (-1, -2), (-1, -1), (0, -2), (0, -1)], // 3->1
	],
	i: [
		[(0, 0), (1, 0), (-2, 0), (-2, 1), (1, -2)],  // 0->1
		[(0, 0), (-1, 0), (2, 0), (-1, 2), (2, -1)],  // 1->0
		[(0, 0), (-1, 0), (2, 0), (-1, -2), (2, 1)],  // 1->2
		[(0, 0), (-2, 0), (1, 0), (-2, -1), (1, 2)],  // 2->1
		[(0, 0), (2, 0), (-1, 0), (2, -1), (-1, 2)],  // 2->3
		[(0, 0), (1, 0), (-2, 0), (1, -2), (-2, 1)],  // 3->2
		[(0, 0), (1, 0), (-2, 0), (1, 2), (-2, -1)],  // 3->0
		[(0, 0), (-1, 0), (2, 0), (2, 1), (-1, -2)],  // 0->3
		[(0, 0), (0, -1), (0, 0), (0, 0), (0, 0)],    // 0->2
		[(0, 0), (1, 0), (0, 0), (0, 0), (0, 0)],     // 1->3
		[(0, 0), (0, 1), (0, 0), (0, 0), (0, 0)],     // 2->0
		[(0, 0), (-1, 0), (0, 0), (0, 0), (0, 0)],    // 3->1
	],
};

fn get_index(from: u8, to: u8) -> u8 {
	assert!(from < 4 && to < 4 && from >= 0 && to >= 0 && from != to, "Invalid rotation transition from {} to {}", from, to);
	match (from, to) {
		(0, 1) => 0,
		(1, 0) => 1,
		(1, 2) => 2,
		(2, 1) => 3,
		(2, 3) => 4,
		(3, 2) => 5,
		(3, 0) => 6,
		(0, 3) => 7,
		(0, 2) => 8,
		(1, 3) => 9,
		(2, 0) => 10,
		(3, 1) => 11,
		_ => panic!("Invalid rotation transition from {} to {}", from, to),
	}
}

pub fn get_kick_data(mino: Mino, table: KickTable, from: u8, to: u8) -> &'static [(i8, i8); 5] {
	let kick_table = match table {
		KickTable::SRS => &SRS_KICKS,
		KickTable::SRSPlus => &SRS_PLUS_KICKS,
	};
  match mino {
    Mino::I => &kick_table.i[get_index(from, to) as usize],
    _ => &kick_table.standard[get_index(from, to) as usize],
  }
}